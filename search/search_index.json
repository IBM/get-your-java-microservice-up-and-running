{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Workshop: Get your Java Microservice up and running \u00b6 This workshop demonstrates how to build a Microservice with Java and how to deploy it to Kubernetes on the IBM Cloud. The Microservice in this workshop is kept as simple as possible, so that it can be used as a starting point for other Microservices. The Microservice has been developed with Java EE and Eclipse MicroProfile . Useful playlist on YouTube related to this workshop: Build and deploy a microservice to Kubernetes What's a Microservice \u00b6 There are small variations of microservice definitions out there, here is one definition of Gartner : A microservice is a service-oriented application component that is tightly scoped, strongly encapsulated, loosely coupled, independently deployable and independently scalable. More additional information related to microservices provided by IBM. Architecture \u00b6 In the gif below you see the Authors Microservice, which we will run locally in a Docker container. We will deploy this Authors Microservice to Kubernetes on IBM Cloud. The gif shows the steps of exercise 3 how we deploy that Microservice to IBM Cloud. Estimated time and level \u00b6 Time Level one hour beginners Objectives \u00b6 After you complete this workshop, you'll understand the following topics: Java implementation of a Cloud Native RESTFul Java Microservice built on open technologies MicroProfile and OpenLiberty. Describe how to effectively build and run a Microservice on a local machine in a container Understands the steps needed to deploy a single Microservice to Kubernetes and on the IBM Cloud Kubernetes service You can verify your learning in the Cloud Native Starter Badge - Level 1 To be prepared to pass the test of the Cloud Native Starter Badge - Level 1 , you should run the hands-on workshop virtual or face to face , but you can also run the workshop as a self service . About this workshop \u00b6 The introductory page of the workshop is broken down into the following sections: Agenda Compatibility Technology Used Credits What`s next? Agenda \u00b6 These are the sections of this workshop, go through all of them in sequence, start with Setup local and IBM Cloud Environment : Setup local and IBM Cloud Environment Running the Java Microservice locally The Java implementation Deploy to the Kubernetes Optional labs: Deploy to Code Engine Compatibility \u00b6 This workshop has been tested on the following platforms: IBM Cloud Kubernetes Service : Kubernetes Version 1.17 on IBM Cloud Docker desktop : Version 2.3.0.4 Technology Used \u00b6 Microservices architecture Jakarta EE MicroProfile Open Liberty git cURL IBM Cloud CLI IBM Cloud CLI releases Docker kubectl Credits \u00b6 Niklas Heidloff Harald Uebele Thomas S\u00fcdbr\u00f6cker Additional resources \u00b6 Here are some documentations of the project.","title":"About the workshop"},{"location":"#workshop-get-your-java-microservice-up-and-running","text":"This workshop demonstrates how to build a Microservice with Java and how to deploy it to Kubernetes on the IBM Cloud. The Microservice in this workshop is kept as simple as possible, so that it can be used as a starting point for other Microservices. The Microservice has been developed with Java EE and Eclipse MicroProfile . Useful playlist on YouTube related to this workshop: Build and deploy a microservice to Kubernetes","title":"Workshop: Get your Java Microservice up and running"},{"location":"#whats-a-microservice","text":"There are small variations of microservice definitions out there, here is one definition of Gartner : A microservice is a service-oriented application component that is tightly scoped, strongly encapsulated, loosely coupled, independently deployable and independently scalable. More additional information related to microservices provided by IBM.","title":"What's a Microservice"},{"location":"#architecture","text":"In the gif below you see the Authors Microservice, which we will run locally in a Docker container. We will deploy this Authors Microservice to Kubernetes on IBM Cloud. The gif shows the steps of exercise 3 how we deploy that Microservice to IBM Cloud.","title":"Architecture"},{"location":"#estimated-time-and-level","text":"Time Level one hour beginners","title":"Estimated time and level"},{"location":"#objectives","text":"After you complete this workshop, you'll understand the following topics: Java implementation of a Cloud Native RESTFul Java Microservice built on open technologies MicroProfile and OpenLiberty. Describe how to effectively build and run a Microservice on a local machine in a container Understands the steps needed to deploy a single Microservice to Kubernetes and on the IBM Cloud Kubernetes service You can verify your learning in the Cloud Native Starter Badge - Level 1 To be prepared to pass the test of the Cloud Native Starter Badge - Level 1 , you should run the hands-on workshop virtual or face to face , but you can also run the workshop as a self service .","title":"Objectives"},{"location":"#about-this-workshop","text":"The introductory page of the workshop is broken down into the following sections: Agenda Compatibility Technology Used Credits What`s next?","title":"About this workshop"},{"location":"#agenda","text":"These are the sections of this workshop, go through all of them in sequence, start with Setup local and IBM Cloud Environment : Setup local and IBM Cloud Environment Running the Java Microservice locally The Java implementation Deploy to the Kubernetes Optional labs: Deploy to Code Engine","title":"Agenda"},{"location":"#compatibility","text":"This workshop has been tested on the following platforms: IBM Cloud Kubernetes Service : Kubernetes Version 1.17 on IBM Cloud Docker desktop : Version 2.3.0.4","title":"Compatibility"},{"location":"#technology-used","text":"Microservices architecture Jakarta EE MicroProfile Open Liberty git cURL IBM Cloud CLI IBM Cloud CLI releases Docker kubectl","title":"Technology Used"},{"location":"#credits","text":"Niklas Heidloff Harald Uebele Thomas S\u00fcdbr\u00f6cker","title":"Credits"},{"location":"#additional-resources","text":"Here are some documentations of the project.","title":"Additional resources"},{"location":"SUMMARY/","text":"Summary \u00b6 Setup local and IBM Cloud Environment \u00b6 Overview Register for IBM Cloud Apply your feature code Create a free Kubernetes cluster Configure the container registry Setup for local development and cloud deployment Access the Kubernetes cluster Exercises \u00b6 Exercise 1: Running the Java Microservice locally Exercise 2: The Java implementation Exercise 3: Deploy to the Kubernetes Additional Resources \u00b6 Cloud-Native-Starter project Security Reactive","title":"Summary"},{"location":"SUMMARY/#summary","text":"","title":"Summary"},{"location":"SUMMARY/#setup-local-and-ibm-cloud-environment","text":"Overview Register for IBM Cloud Apply your feature code Create a free Kubernetes cluster Configure the container registry Setup for local development and cloud deployment Access the Kubernetes cluster","title":"Setup local and IBM Cloud Environment"},{"location":"SUMMARY/#exercises","text":"Exercise 1: Running the Java Microservice locally Exercise 2: The Java implementation Exercise 3: Deploy to the Kubernetes","title":"Exercises"},{"location":"SUMMARY/#additional-resources","text":"Cloud-Native-Starter project Security Reactive","title":"Additional Resources"},{"location":"exercise-01/","text":"Running the Java Microservice locally \u00b6 Note: This lab is structured in understanding and hands-on tasks . Step 1: Understanding \u00b6 In this workshop we run a Microservice that has been implemented with Java EE and Eclipse MicroProfile . The Microservice has been kept as simple as possible, so that it can be used as a starting point for other Microservices. It contains the following functionality: Image with OpenJ9, OpenJDK, Open Liberty and MicroProfile: Dockerfile Maven project: pom.xml Open Liberty server configuration: server.xml Health endpoint: HealthEndpoint.java Kubernetes yaml files: deployment.yaml and service.yaml Sample REST GET endpoint: AuthorsApplication.java , GetAuthor.java and Author.java This service provides a REST API 'getauthor'. Normally we would use a database but in this example we just simulate with local sample data. With this small example we touch the following topics: Usage of Maven for Java Configuration of an OpenLiberty Server Implementation of a REST GET endpoint with MicroProfile Health check implementation using a MicroProfile for Kubernetes Definition of a Dockerfile with the reuse for existing containers from Dockerhub Definition of the Image \u00b6 For the image we use a stack of open source components to run the Java Microservice on Open Liberty. OpenJ9 0.12.1 OpenJDK 8u202-b08 from AdoptOpenJDK Open Liberty 18.0.0.4 MicroProfile 3.0 In the Dockerfile we define how to build the container image. For detailed information check the Dockerfile documentation . When we build a new container image we usually start with an existing container image that already contains a minimum of the configuration we need, for example the OS, the Java version or even more. For this we search DockerHub or on the internet to find a starting point which fits to our needs. Using a multi-stage build . \u00b6 Inside of our Dockerfile we use two stages to build the container image . The reason for the two stages is that we want to be independend of an existing local environment when we build our production services. With this concept we don't have to ensure that e.g. Java and Maven or correct versions of them are installed on the local machine of the developers. With this two stage approach there is one container responsible to build the Microservice, let us call this container build environment container, and another container will contain the Microservice itself, we call this the production container. Only this production container is later used. Build environment container \u00b6 In the following Dockerfile sample we can see how we create our build environment container based on the maven 3.5 image from DockerHub . We use the pom file that we defined before to build our Authors service with RUN mvn -f /usr/src/app/pom.xml clean package . FROM maven:3.5-jdk-8 as BUILD COPY src /usr/src/app/src COPY pom.xml /usr/src/app RUN mvn -f /usr/src/app/pom.xml clean package Production container \u00b6 The starting point for the Production container is an OpenLiberty container . We copy the Authors service code together with the server.xml for the OpenLiberty server to this container. Note: The service.xml defines port 3000 as the port where we can reach the Authors Microservice. That port must be exposed with EXPOSE 3000 in the Dockerfile. FROM open-liberty:19.0.0.9-kernel-java11 COPY liberty/server.xml /config/ COPY --from = 0 /usr/src/app/target/authors.war /config/apps/ # This script will add the requested XML snippets, grow image to be fit-for-purpose and apply interim fixes # https://github.com/WASdev/ci.docker RUN configure.sh EXPOSE 3000 Step 2: Hands-on tasks - Run the container locally \u00b6 That lab needs a local Docker installation. Step 1: Test the Microservice in a local container \u00b6 Open the the Terminal session where you cloned the Cloud-Native-Starter project to your local computer. cd $ROOT_FOLDER /authors-java-jee docker build -t authors . docker run -i --rm -p 3000 :3000 authors Step 2: Open the Swagger UI of the mircoservice in a browser \u00b6 http://localhost:3000/openapi/ui/ Congratulations you have finished exercise 1 .","title":"Lab 1. Running the Java Microservice locally"},{"location":"exercise-01/#running-the-java-microservice-locally","text":"Note: This lab is structured in understanding and hands-on tasks .","title":"Running the Java Microservice locally"},{"location":"exercise-01/#step-1-understanding","text":"In this workshop we run a Microservice that has been implemented with Java EE and Eclipse MicroProfile . The Microservice has been kept as simple as possible, so that it can be used as a starting point for other Microservices. It contains the following functionality: Image with OpenJ9, OpenJDK, Open Liberty and MicroProfile: Dockerfile Maven project: pom.xml Open Liberty server configuration: server.xml Health endpoint: HealthEndpoint.java Kubernetes yaml files: deployment.yaml and service.yaml Sample REST GET endpoint: AuthorsApplication.java , GetAuthor.java and Author.java This service provides a REST API 'getauthor'. Normally we would use a database but in this example we just simulate with local sample data. With this small example we touch the following topics: Usage of Maven for Java Configuration of an OpenLiberty Server Implementation of a REST GET endpoint with MicroProfile Health check implementation using a MicroProfile for Kubernetes Definition of a Dockerfile with the reuse for existing containers from Dockerhub","title":"Step 1: Understanding"},{"location":"exercise-01/#definition-of-the-image","text":"For the image we use a stack of open source components to run the Java Microservice on Open Liberty. OpenJ9 0.12.1 OpenJDK 8u202-b08 from AdoptOpenJDK Open Liberty 18.0.0.4 MicroProfile 3.0 In the Dockerfile we define how to build the container image. For detailed information check the Dockerfile documentation . When we build a new container image we usually start with an existing container image that already contains a minimum of the configuration we need, for example the OS, the Java version or even more. For this we search DockerHub or on the internet to find a starting point which fits to our needs.","title":"Definition of the Image"},{"location":"exercise-01/#using-a-multi-stage-build","text":"Inside of our Dockerfile we use two stages to build the container image . The reason for the two stages is that we want to be independend of an existing local environment when we build our production services. With this concept we don't have to ensure that e.g. Java and Maven or correct versions of them are installed on the local machine of the developers. With this two stage approach there is one container responsible to build the Microservice, let us call this container build environment container, and another container will contain the Microservice itself, we call this the production container. Only this production container is later used.","title":"Using a multi-stage build."},{"location":"exercise-01/#build-environment-container","text":"In the following Dockerfile sample we can see how we create our build environment container based on the maven 3.5 image from DockerHub . We use the pom file that we defined before to build our Authors service with RUN mvn -f /usr/src/app/pom.xml clean package . FROM maven:3.5-jdk-8 as BUILD COPY src /usr/src/app/src COPY pom.xml /usr/src/app RUN mvn -f /usr/src/app/pom.xml clean package","title":"Build environment container"},{"location":"exercise-01/#production-container","text":"The starting point for the Production container is an OpenLiberty container . We copy the Authors service code together with the server.xml for the OpenLiberty server to this container. Note: The service.xml defines port 3000 as the port where we can reach the Authors Microservice. That port must be exposed with EXPOSE 3000 in the Dockerfile. FROM open-liberty:19.0.0.9-kernel-java11 COPY liberty/server.xml /config/ COPY --from = 0 /usr/src/app/target/authors.war /config/apps/ # This script will add the requested XML snippets, grow image to be fit-for-purpose and apply interim fixes # https://github.com/WASdev/ci.docker RUN configure.sh EXPOSE 3000","title":"Production container"},{"location":"exercise-01/#step-2-hands-on-tasks-run-the-container-locally","text":"That lab needs a local Docker installation.","title":"Step 2: Hands-on tasks - Run the container locally"},{"location":"exercise-01/#step-1-test-the-microservice-in-a-local-container","text":"Open the the Terminal session where you cloned the Cloud-Native-Starter project to your local computer. cd $ROOT_FOLDER /authors-java-jee docker build -t authors . docker run -i --rm -p 3000 :3000 authors","title":"Step 1: Test the Microservice in a local container"},{"location":"exercise-01/#step-2-open-the-swagger-ui-of-the-mircoservice-in-a-browser","text":"http://localhost:3000/openapi/ui/ Congratulations you have finished exercise 1 .","title":"Step 2: Open the Swagger UI of the mircoservice in a browser"},{"location":"exercise-02/","text":"Exercise 3 - The Java Implementation \u00b6 Note: This exercise is structured in understanding and hands-on tasks . Step 1: Understand \u00b6 1 Usage of Maven for Java \u00b6 We begin with the Maven part for our Java project. Maven Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information. In the pom file we define the configuration of our Java project with dependencies, build, and properties including the compiler information as you can see in the pom file below. <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> com.ibm.cloud </groupId> <artifactId> authors </artifactId> <version> 1.0-SNAPSHOT </version> <packaging> war </packaging> <dependencies> <dependency> <groupId> org.eclipse.microprofile </groupId> <artifactId> microprofile </artifactId> <version> 3.0 </version> <scope> provided </scope> <type> pom </type> </dependency> </dependencies> <build> <finalName> authors </finalName> </build> <properties> <maven.compiler.source> 1.8 </maven.compiler.source> <maven.compiler.target> 1.8 </maven.compiler.target> <failOnMissingWebXml> false </failOnMissingWebXml> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> </properties> </project> REMEMBER: We use this pom file to build our Authors service with RUN mvn -f /usr/src/app/pom.xml clean package inside our Build environment container . FROM maven:3.5-jdk-8 as BUILD COPY src /usr/src/app/src COPY pom.xml /usr/src/app RUN mvn -f /usr/src/app/pom.xml clean package 2 Configuration of the Open Liberty Server \u00b6 Our Authors Microservice will run on an OpenLiberty Server in a container on Kubernetes. We need to configure the OpenLiberty server with a server.xml file. For our Java implementation we decided to use MicroProfile and within the feature definition in the server.xml we provide this information to our server with the entry microProfile-3 . The server must be reached in the network. Therefore we define the httpEndpoint including httpPort we use for our microservice. For configuration details take a look into the openliberty documentation . IMPORTANT: We should remember that this port ( httpPort=\"3000\" ) must be exposed in the Dockerfile for our container and mapped inside the Kubernetes deployment configuration. Also the name of the executable web application is definied in the server.xml . <?xml version=\"1.0\" encoding=\"UTF-8\"?> <server description= \"OpenLiberty Server\" > <featureManager> <feature> microProfile-3 </feature> </featureManager> <httpEndpoint id= \"defaultHttpEndpoint\" host= \"*\" httpPort= \"3000\" httpsPort= \"9443\" /> <webApplication location= \"authors.war\" contextRoot= \"api\" /> </server> Note: Later we will change the contextRoot . 3 Implementation of the REST GET endpoint with MicroProfile \u00b6 3.1 MicroProfile basics \u00b6 Some definitions: Microservice architecture is a popular approach for building cloud-native applications in which each capability is developed as an independent service. It enables small, autonomous teams to develop, deploy, and scale their respective services independently. Eclipse MicroProfile is a modular set of technologies designed so that you can write cloud-native Java\u2122 Microservices. MicroProfile utilizes some of existing tools (JAX-RS, CDI, JSON-P for example), and combine them with new ones to create a baseline platform optimized for a Microservice architecture. In the following image you see a list of MicroProfile specifications, we will use the red marked ones. 3.2 Java classes needed to expose the Authors service \u00b6 For the Authors service to expose the REST API we need to implement three classes: AuthorsApplication class repesents our web application. Author class repesents the data structure we use for the Author. GetAuthor class repesents the REST API. 3.2.1 Class AuthorsApplication \u00b6 Our web application does not implement any business or other logic, it simply needs to run on a server with no UI. The AuthorsApplication class extends the javax.ws.rs.core.Application class to do this. The AuthorsApplication class provides access to the classes from the com.ibm.authors package at runtime. The implementation of the interface class Application enables the usage of easy REST implementation provided by MircoProfile. With @ApplicationPath from MicroProfile we define the base path of the application. package com.ibm.authors ; // JAX-RS from Microprofile specification import javax.ws.rs.core.Application ; import javax.ws.rs.ApplicationPath ; // JAX-RS from Microprofile specification @ApplicationPath ( \"v1\" ) public class AuthorsApplication extends Application { } Note: Later we will change the ApplicationPath in this class. 3.2.2 Class Author \u00b6 This class simply repesents the data structure we use for the Author . No MircoProfile feature is used here. package com.ibm.authors ; public class Author { public String name ; public String twitter ; public String blog ; } 3.2.3 Class GetAuthor \u00b6 This class implements the REST API response for our Authors Microservice. We implement the REST endpoint using the MicroProfile REST Client . We use @Path and @Get statements from JAX-RS for the REST endpoint and for the OpenAPI documentation we use @OpenAPIDefinition statements. When you add MicroProfile with OpenAPI , OpenAPI always creates automatically an OpenAPI explorer for you. REMEMBER: In the server.xml configuration we added MicroProfile to the Open Liberty server as a feature, as you see in the code below. <featureManager> <feature> microProfile-3 </feature> .... </featureManager> With the combination of the server.xml and our usage of MicroProfile features in the GetAuthor class we will be able to access an OpenAPI explorer with this URL http://host:http_port/openapi later. This is the source code of the GetAuthors class with the mentioned MicroProfile features: // JAX-RS from Microprofile specification @ApplicationScoped @Path ( \"/getauthor\" ) // OpenAPI from Microprofile specification @OpenAPIDefinition ( info = @Info ( title = \"Authors Service\" , version = \"1.0\" , description = \"Authors Service APIs\" , contact = @Contact ( url = \"https://github.com/nheidloff/cloud-native-starter\" , name = \"Niklas Heidloff\" ), license = @License ( name = \"License\" , url = \"https://github.com/nheidloff/cloud-native-starter/blob/master/LICENSE\" ))) public class GetAuthor { // JAX-RS from Microprofile specification @GET // OpenAPI from Microprofile specification @APIResponses ( value = { @APIResponse ( responseCode = \"404\" , description = \"Author Not Found\" ), @APIResponse ( responseCode = \"200\" , description = \"Author with requested name\" , content = @Content ( mediaType = \"application/json\" , schema = @Schema ( implementation = Author . class ) ) ), @APIResponse ( responseCode = \"500\" , description = \"Internal service error\" ) }) @Operation ( summary = \"Get specific author\" , description = \"Get specific author\" ) public Response getAuthor ( @Parameter ( description = \"The unique name of the author\" , required = true , example = \"Niklas Heidloff\" , schema = @Schema ( type = SchemaType . STRING )) @QueryParam ( \"name\" ) String name ) { Author author = new Author (); author . name = \"Niklas Heidloff\" ; author . twitter = \"https://twitter.com/nheidloff\" ; author . blog = \"http://heidloff.net\" ; return Response . ok ( this . createJson ( author )). build (); } private JsonObject createJson ( Author author ) { JsonObject output = Json . createObjectBuilder (). add ( \"name\" , author . name ). add ( \"twitter\" , author . twitter ) . add ( \"blog\" , author . blog ). build (); return output ; } } Note: Later we will change the return values for the response in the local source code. 3.3 Supporting live and readiness probes in Kubernetes with HealthCheck \u00b6 We have added the class HealthEndpoint to the Authors package as you see in the following diagram. We want to support this Kubernetes function : Kubernetes provides liveness and readiness probes that are used to check the health of your containers. These probes can check certain files in your containers, check a TCP socket, or make HTTP requests. MicroProfile Health exposes readiness and liveness endpoints on your Microservices. Kubernetes polls these endpoints as specified by the probes to react appropriately to any change in the Microservice\u2019s status. For more information check the Kubernetes Microprofile Health documentation and the documentation on GitHub . This is the implementation of the Health Check for Kubernetes in the HealthEndpoint class of the Authors service: @Readiness public class HealthEndpoint implements HealthCheck { @Override public HealthCheckResponse call () { return HealthCheckResponse . named ( \"authors\" ). withData ( \"authors\" , \"ok\" ). up (). build (); } } Note: Later we will change return information of the HealthCheckResponse . This HealthEndpoint is configured in the Kubernetes deployment yaml. In the following yaml extract we see the livenessProbe definition. livenessProbe : exec : command : [ \"sh\" , \"-c\" , \"curl -s http://localhost:3000/\" ] initialDelaySeconds : 20 readinessProbe : exec : command : [ \"sh\" , \"-c\" , \"curl -s http://localhost:3000/health | grep -q authors\" ] initialDelaySeconds : 40 Step 2: Hands-on tasks \u00b6 Change the code of the authors Microservice and run the service in a container locally \u00b6 Note: That lab does only need Docker and a terminal session on your local machine. Step 1: Open a terminal session on you local machine \u00b6 cd $ROOT_FOLDER /authors-java-jee docker build -t authors . docker run -i --rm -p 3000 :3000 authors Step 2: Update server.xml \u00b6 Change the contextRoot in server.xml to something similar like \"myapi\" Open the file cloud-native-starter/authors-java-jee/liberty/server.xml in a editor and change the value. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <server description= \"OpenLiberty Server\" > <featureManager> <feature> microProfile-3 </feature> </featureManager> <httpEndpoint id= \"defaultHttpEndpoint\" host= \"*\" httpPort= \"3000\" httpsPort= \"9443\" /> <webApplication location= \"authors.war\" contextRoot= \"myapi\" /> </server> Step 3: Update AuthorsApplication.java \u00b6 Change the @ApplicationPath in the class AuthorsApplication.java something similar like \"myv1\" Open the file cloud-native-starter/authors-java-jee/src/main/java/com/ibm/authors/AuthorsApplication.java in a editor and change the value. package com.ibm.authors ; import javax.ws.rs.core.Application ; import javax.ws.rs.ApplicationPath ; @ApplicationPath ( \"myv1\" ) public class AuthorsApplication extends Application { } Step 4: Update GetAuthor.java \u00b6 In the class GetAuthor.java change the returned author name to something similar like \"MY NAME\" Open the file cloud-native-starter/authors-java-jee/src/main/java/com/ibm/authors/GetAuthor.java in a editor and change the value. public Response getAuthor ( @Parameter ( description = \"The unique name of the author\" , required = true , example = \"MY NAME\" , schema = @Schema ( type = SchemaType . STRING )) @QueryParam ( \"name\" ) String name ) { Author author = new Author (); author . name = \"MY NAME\" ; author . twitter = \"https://twitter.com/MY NAME\" ; author . blog = \"http://MY NAME.net\" ; return Response . ok ( this . createJson ( author )). build (); } Step 5: Update HealthEndpoint.java \u00b6 In the class HealthEndpoint.java change the returned information to something similar like \"ok for the workshop\" @Health @ApplicationScoped public class HealthEndpoint implements HealthCheck { @Override public HealthCheckResponse call () { return HealthCheckResponse . named ( \"authors\" ). withData ( \"authors\" , \"ok for the workshop\" ). up (). build (); } } Step 6: To test and see how the code works you can run the code locally as a Docker container \u00b6 cd $ROOT_FOLDER /authors-java-jee docker build -t authors . docker run -i --rm -p 3000 :3000 authors Step 7: Open the swagger UI of the mircoservice in a browser and verfiy the changes \u00b6 http://localhost:3000/openapi/ui/ Step 8: Open the health check of the mircoservice in a browser and verfiy the changes \u00b6 http://localhost:3000/health Congratulations you have finished exercise 2 .","title":"Lab 2. The Java implementation"},{"location":"exercise-02/#exercise-3-the-java-implementation","text":"Note: This exercise is structured in understanding and hands-on tasks .","title":"Exercise 3 - The Java Implementation"},{"location":"exercise-02/#step-1-understand","text":"","title":"Step 1: Understand"},{"location":"exercise-02/#1-usage-of-maven-for-java","text":"We begin with the Maven part for our Java project. Maven Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information. In the pom file we define the configuration of our Java project with dependencies, build, and properties including the compiler information as you can see in the pom file below. <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> com.ibm.cloud </groupId> <artifactId> authors </artifactId> <version> 1.0-SNAPSHOT </version> <packaging> war </packaging> <dependencies> <dependency> <groupId> org.eclipse.microprofile </groupId> <artifactId> microprofile </artifactId> <version> 3.0 </version> <scope> provided </scope> <type> pom </type> </dependency> </dependencies> <build> <finalName> authors </finalName> </build> <properties> <maven.compiler.source> 1.8 </maven.compiler.source> <maven.compiler.target> 1.8 </maven.compiler.target> <failOnMissingWebXml> false </failOnMissingWebXml> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> </properties> </project> REMEMBER: We use this pom file to build our Authors service with RUN mvn -f /usr/src/app/pom.xml clean package inside our Build environment container . FROM maven:3.5-jdk-8 as BUILD COPY src /usr/src/app/src COPY pom.xml /usr/src/app RUN mvn -f /usr/src/app/pom.xml clean package","title":"1 Usage of Maven for Java"},{"location":"exercise-02/#2-configuration-of-the-open-liberty-server","text":"Our Authors Microservice will run on an OpenLiberty Server in a container on Kubernetes. We need to configure the OpenLiberty server with a server.xml file. For our Java implementation we decided to use MicroProfile and within the feature definition in the server.xml we provide this information to our server with the entry microProfile-3 . The server must be reached in the network. Therefore we define the httpEndpoint including httpPort we use for our microservice. For configuration details take a look into the openliberty documentation . IMPORTANT: We should remember that this port ( httpPort=\"3000\" ) must be exposed in the Dockerfile for our container and mapped inside the Kubernetes deployment configuration. Also the name of the executable web application is definied in the server.xml . <?xml version=\"1.0\" encoding=\"UTF-8\"?> <server description= \"OpenLiberty Server\" > <featureManager> <feature> microProfile-3 </feature> </featureManager> <httpEndpoint id= \"defaultHttpEndpoint\" host= \"*\" httpPort= \"3000\" httpsPort= \"9443\" /> <webApplication location= \"authors.war\" contextRoot= \"api\" /> </server> Note: Later we will change the contextRoot .","title":"2 Configuration of the Open Liberty Server"},{"location":"exercise-02/#3-implementation-of-the-rest-get-endpoint-with-microprofile","text":"","title":"3 Implementation of the REST GET endpoint with MicroProfile"},{"location":"exercise-02/#31-microprofile-basics","text":"Some definitions: Microservice architecture is a popular approach for building cloud-native applications in which each capability is developed as an independent service. It enables small, autonomous teams to develop, deploy, and scale their respective services independently. Eclipse MicroProfile is a modular set of technologies designed so that you can write cloud-native Java\u2122 Microservices. MicroProfile utilizes some of existing tools (JAX-RS, CDI, JSON-P for example), and combine them with new ones to create a baseline platform optimized for a Microservice architecture. In the following image you see a list of MicroProfile specifications, we will use the red marked ones.","title":"3.1 MicroProfile basics"},{"location":"exercise-02/#32-java-classes-needed-to-expose-the-authors-service","text":"For the Authors service to expose the REST API we need to implement three classes: AuthorsApplication class repesents our web application. Author class repesents the data structure we use for the Author. GetAuthor class repesents the REST API.","title":"3.2 Java classes needed to expose the Authors service"},{"location":"exercise-02/#321-class-authorsapplication","text":"Our web application does not implement any business or other logic, it simply needs to run on a server with no UI. The AuthorsApplication class extends the javax.ws.rs.core.Application class to do this. The AuthorsApplication class provides access to the classes from the com.ibm.authors package at runtime. The implementation of the interface class Application enables the usage of easy REST implementation provided by MircoProfile. With @ApplicationPath from MicroProfile we define the base path of the application. package com.ibm.authors ; // JAX-RS from Microprofile specification import javax.ws.rs.core.Application ; import javax.ws.rs.ApplicationPath ; // JAX-RS from Microprofile specification @ApplicationPath ( \"v1\" ) public class AuthorsApplication extends Application { } Note: Later we will change the ApplicationPath in this class.","title":"3.2.1 Class AuthorsApplication"},{"location":"exercise-02/#322-class-author","text":"This class simply repesents the data structure we use for the Author . No MircoProfile feature is used here. package com.ibm.authors ; public class Author { public String name ; public String twitter ; public String blog ; }","title":"3.2.2 Class Author"},{"location":"exercise-02/#323-class-getauthor","text":"This class implements the REST API response for our Authors Microservice. We implement the REST endpoint using the MicroProfile REST Client . We use @Path and @Get statements from JAX-RS for the REST endpoint and for the OpenAPI documentation we use @OpenAPIDefinition statements. When you add MicroProfile with OpenAPI , OpenAPI always creates automatically an OpenAPI explorer for you. REMEMBER: In the server.xml configuration we added MicroProfile to the Open Liberty server as a feature, as you see in the code below. <featureManager> <feature> microProfile-3 </feature> .... </featureManager> With the combination of the server.xml and our usage of MicroProfile features in the GetAuthor class we will be able to access an OpenAPI explorer with this URL http://host:http_port/openapi later. This is the source code of the GetAuthors class with the mentioned MicroProfile features: // JAX-RS from Microprofile specification @ApplicationScoped @Path ( \"/getauthor\" ) // OpenAPI from Microprofile specification @OpenAPIDefinition ( info = @Info ( title = \"Authors Service\" , version = \"1.0\" , description = \"Authors Service APIs\" , contact = @Contact ( url = \"https://github.com/nheidloff/cloud-native-starter\" , name = \"Niklas Heidloff\" ), license = @License ( name = \"License\" , url = \"https://github.com/nheidloff/cloud-native-starter/blob/master/LICENSE\" ))) public class GetAuthor { // JAX-RS from Microprofile specification @GET // OpenAPI from Microprofile specification @APIResponses ( value = { @APIResponse ( responseCode = \"404\" , description = \"Author Not Found\" ), @APIResponse ( responseCode = \"200\" , description = \"Author with requested name\" , content = @Content ( mediaType = \"application/json\" , schema = @Schema ( implementation = Author . class ) ) ), @APIResponse ( responseCode = \"500\" , description = \"Internal service error\" ) }) @Operation ( summary = \"Get specific author\" , description = \"Get specific author\" ) public Response getAuthor ( @Parameter ( description = \"The unique name of the author\" , required = true , example = \"Niklas Heidloff\" , schema = @Schema ( type = SchemaType . STRING )) @QueryParam ( \"name\" ) String name ) { Author author = new Author (); author . name = \"Niklas Heidloff\" ; author . twitter = \"https://twitter.com/nheidloff\" ; author . blog = \"http://heidloff.net\" ; return Response . ok ( this . createJson ( author )). build (); } private JsonObject createJson ( Author author ) { JsonObject output = Json . createObjectBuilder (). add ( \"name\" , author . name ). add ( \"twitter\" , author . twitter ) . add ( \"blog\" , author . blog ). build (); return output ; } } Note: Later we will change the return values for the response in the local source code.","title":"3.2.3 Class GetAuthor"},{"location":"exercise-02/#33-supporting-live-and-readiness-probes-in-kubernetes-with-healthcheck","text":"We have added the class HealthEndpoint to the Authors package as you see in the following diagram. We want to support this Kubernetes function : Kubernetes provides liveness and readiness probes that are used to check the health of your containers. These probes can check certain files in your containers, check a TCP socket, or make HTTP requests. MicroProfile Health exposes readiness and liveness endpoints on your Microservices. Kubernetes polls these endpoints as specified by the probes to react appropriately to any change in the Microservice\u2019s status. For more information check the Kubernetes Microprofile Health documentation and the documentation on GitHub . This is the implementation of the Health Check for Kubernetes in the HealthEndpoint class of the Authors service: @Readiness public class HealthEndpoint implements HealthCheck { @Override public HealthCheckResponse call () { return HealthCheckResponse . named ( \"authors\" ). withData ( \"authors\" , \"ok\" ). up (). build (); } } Note: Later we will change return information of the HealthCheckResponse . This HealthEndpoint is configured in the Kubernetes deployment yaml. In the following yaml extract we see the livenessProbe definition. livenessProbe : exec : command : [ \"sh\" , \"-c\" , \"curl -s http://localhost:3000/\" ] initialDelaySeconds : 20 readinessProbe : exec : command : [ \"sh\" , \"-c\" , \"curl -s http://localhost:3000/health | grep -q authors\" ] initialDelaySeconds : 40","title":"3.3 Supporting live and readiness probes in Kubernetes with HealthCheck"},{"location":"exercise-02/#step-2-hands-on-tasks","text":"","title":"Step 2: Hands-on tasks"},{"location":"exercise-02/#change-the-code-of-the-authors-microservice-and-run-the-service-in-a-container-locally","text":"Note: That lab does only need Docker and a terminal session on your local machine.","title":"Change the code of the authors Microservice and run the service in a container locally"},{"location":"exercise-02/#step-1-open-a-terminal-session-on-you-local-machine","text":"cd $ROOT_FOLDER /authors-java-jee docker build -t authors . docker run -i --rm -p 3000 :3000 authors","title":"Step 1: Open a terminal session on you local machine"},{"location":"exercise-02/#step-2-update-serverxml","text":"Change the contextRoot in server.xml to something similar like \"myapi\" Open the file cloud-native-starter/authors-java-jee/liberty/server.xml in a editor and change the value. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <server description= \"OpenLiberty Server\" > <featureManager> <feature> microProfile-3 </feature> </featureManager> <httpEndpoint id= \"defaultHttpEndpoint\" host= \"*\" httpPort= \"3000\" httpsPort= \"9443\" /> <webApplication location= \"authors.war\" contextRoot= \"myapi\" /> </server>","title":"Step 2: Update server.xml"},{"location":"exercise-02/#step-3-update-authorsapplicationjava","text":"Change the @ApplicationPath in the class AuthorsApplication.java something similar like \"myv1\" Open the file cloud-native-starter/authors-java-jee/src/main/java/com/ibm/authors/AuthorsApplication.java in a editor and change the value. package com.ibm.authors ; import javax.ws.rs.core.Application ; import javax.ws.rs.ApplicationPath ; @ApplicationPath ( \"myv1\" ) public class AuthorsApplication extends Application { }","title":"Step 3: Update AuthorsApplication.java"},{"location":"exercise-02/#step-4-update-getauthorjava","text":"In the class GetAuthor.java change the returned author name to something similar like \"MY NAME\" Open the file cloud-native-starter/authors-java-jee/src/main/java/com/ibm/authors/GetAuthor.java in a editor and change the value. public Response getAuthor ( @Parameter ( description = \"The unique name of the author\" , required = true , example = \"MY NAME\" , schema = @Schema ( type = SchemaType . STRING )) @QueryParam ( \"name\" ) String name ) { Author author = new Author (); author . name = \"MY NAME\" ; author . twitter = \"https://twitter.com/MY NAME\" ; author . blog = \"http://MY NAME.net\" ; return Response . ok ( this . createJson ( author )). build (); }","title":"Step 4: Update GetAuthor.java"},{"location":"exercise-02/#step-5-update-healthendpointjava","text":"In the class HealthEndpoint.java change the returned information to something similar like \"ok for the workshop\" @Health @ApplicationScoped public class HealthEndpoint implements HealthCheck { @Override public HealthCheckResponse call () { return HealthCheckResponse . named ( \"authors\" ). withData ( \"authors\" , \"ok for the workshop\" ). up (). build (); } }","title":"Step 5: Update HealthEndpoint.java"},{"location":"exercise-02/#step-6-to-test-and-see-how-the-code-works-you-can-run-the-code-locally-as-a-docker-container","text":"cd $ROOT_FOLDER /authors-java-jee docker build -t authors . docker run -i --rm -p 3000 :3000 authors","title":"Step 6: To test and see how the code works you can run the code locally as a Docker container"},{"location":"exercise-02/#step-7-open-the-swagger-ui-of-the-mircoservice-in-a-browser-and-verfiy-the-changes","text":"http://localhost:3000/openapi/ui/","title":"Step 7: Open the swagger UI of the mircoservice in a browser and verfiy the changes"},{"location":"exercise-02/#step-8-open-the-health-check-of-the-mircoservice-in-a-browser-and-verfiy-the-changes","text":"http://localhost:3000/health Congratulations you have finished exercise 2 .","title":"Step 8: Open the health check of the mircoservice in a browser and verfiy the changes"},{"location":"exercise-03/","text":"Deploy to Kubernetes \u00b6 In this exercise we will work in the Kubernetes Web Console and with the Kubernetes CLI. \"Kubernetes (K8s) is an open-source system for automating deployment, scaling, and management of containerized applications.\" The following image is a simplified overview of the topics of that lab. This lab has two parts: Start build and save the container image Deploy the application and expose the service We will define and apply a deployment configuration (yaml) to create a Pod with our Microservice We will define a service which routes requests to the Pod with our Microservice The following gif is an animation of the simplified steps above in a sequence. Step 1: Ensure you have the terminal session open with the started Docker image and you have downloaded the Cloud Native Starter project also in this running container \u00b6 Step 2: Navigate to the folder cloud-native-starter/authors-java-jee \u00b6 Note: You have cloned the project twice: first to your local machine and second into the Docker image. The code changes you did in execrise 2 on your local computer, don't exist in the running Docker container. 1. Build and save the container image \u00b6 Step 1: Build and save the container image in the IBM Cloud Container Registry \u00b6 Now we want to build and save a container image in the IBM Cloud Container Registry. Ensure you logon on to IBM Cloud. REMEMBER: You should know this from the prerequisites. You can follow the steps in the Access tab, by starting from After your cluster provision .. and inserting the commands into your terminal session. Logon to the IBM Cloud Container Registry (Ensure you are in the $ROOT_FOLDER/authors-java-jee ) cd $ROOT_FOLDER /authors-java-jee ibmcloud cr login List you namespaces inside the IBM Cloud Container Registry ibmcloud cr namespaces Example output: $ Listing namespaces for account 'Thomas Suedbroecker' s Account ' in registry ' us.icr.io ' ... $ $ Namespace $ cloud-native-suedbro Build the container image using buildah. buildah bud -t [ YOUR_REGISTRY ] / [ YOUR_REGISTRY_NAMESPACE ] /authors:v1 . 5. Now upload the container image to the IBM Cloud Container Registry. We use the information from step 3, where we got the list of namespaces. buildah push [ YOUR_REGISTRY ] / [ YOUR_REGISTRY_NAMESPACE ] /authors:v1 . Example command: * [YOUR_REGISTRY] = us.icr.io * [YOUR_REGISTRY_NAMESPACE] = cloud-native-suedbro buildah push us.icr.io/cloud-native-suedbro/authors:v1 . Optional: Verify the container upload in the IBM Cloud web UI. List the container images to verify the upload. ibmcloud cr images Example output: $ Listing images... $ $ Repository Tag Digest Namespace Created Size Security status $ us.icr.io/cloud-native-suedbro/authors 1 5a86758f1056 cloud-native-suedbro 2 minutes ago 226 MB 3 Issues $ $ OK Copy the REPOSITORY path for the uploaded Authors container image. In this sample case it would be: us.icr.io/cloud-native-suedbro/authors and save it somewhere, we need this later in the deployment.yaml configuration. 2. Apply the Deployment \u00b6 This deployment will deploy a container to a Pod in Kubernetes. For more details we use the Kubernetes documentation for Pods. A Pod is the basic building block of Kubernetes-the smallest and simplest unit in the Kubernetes object model that you create or deploy. A Pod represents processes running on your Cluster . Here is a simplified image for that topic. The deployment.yaml file points to the container image that needs to be instantiated in the pod. Inside the container image cns-workshop-tools you can use the editor nano . nano deployment.yaml Let's start with the deployment yaml. For more details see the Kubernetes documentation for deployments. Definition of kind defines this as a Deployment configuration. kind: Deployment apiVersion: apps/v1 metadata: name: authors In the spec section we specify an app name and version label. spec: ... template: metadata: labels: app: authors version: v1 Then we define a name for the container and we provide the container image location, e.g. where the container can be found in the Container Registry . The containerPort depends on the port definition inside our Dockerfile and in our server.xml. We have previously talked about the usage of the HealthEndpoint class for our Authors service and here we see it the livenessProbe definition. spec: containers: - name: authors image: authors:1 ports: - containerPort: 3000 livenessProbe: This is the full deployment.yaml file. kind : Deployment apiVersion : apps/v1 metadata : name : authors spec : selector : matchLabels : app : authors version : v1 replicas : 1 template : metadata : labels : app : authors version : v1 spec : containers : - name : authors image : us.icr.io/cloud-native-suedbro/authors:1 ports : - containerPort : 3000 livenessProbe : exec : command : [ \"sh\" , \"-c\" , \"curl -s http://localhost:3000/\" ] initialDelaySeconds : 20 readinessProbe : exec : command : [ \"sh\" , \"-c\" , \"curl -s http://localhost:3000/health | grep -q authors\" ] initialDelaySeconds : 40 restartPolicy : Always Step 1: Apply the deployment \u00b6 Ensure you are in the $ROOT_FOLDER/authors-java-jee/deployment cd $ROOT_FOLDER /authors-java-jee/deployment Open the ../authors-java-jee/deployment/deployment.yaml file with a editor and replace the value for the container image location with the path we got from the IBM Container Registry and just replace the authors:1 text, and add following statement imagePullPolicy: Always and save the file. Note: With the specification imagePullPolicy: Always we force that the image is pulled from the IBM Cloud Container Registry and not cashed image in Kubernetes is possible used, when we change our container image IBM Cloud Container Registry. REMEMBER: You should have saved the IBM Container Registry information somewhere. Before: image: authors:1 Sample change: image: us.icr.io/cloud-native-suedbro/authors:1 imagePullPolicy: Always ports: - containerPort: 3000 Now we apply the deployment and we create a new Authors Pod. kubectl apply -f deployment.yaml Step 2: Verify the deployment with kubectl \u00b6 Insert this command and verify the output. kubectl get pods Sample output: NAME READY STATUS RESTARTS AGE authors-7b6dd98db-wl9wc 1 /1 Running 0 6m9s Step 3: Verify the deployment with the Kubernetes dashboard \u00b6 Open your Kubernetes Cluster in the IBM Cloud web console Open the Kubernetes dashbord In the overview you see the created deployment and the pod 3. Apply the service \u00b6 After the definition of the Pod we need to define how to access the Pod. For this we use a service in Kubernetes. For more details see the Kubernetes documentation for service. A Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them - sometimes called a micro-service. The set of Pods targeted by a Service is (usually) determined by a Label Selector. In the service we map the NodePort of the cluster to the port 3000 of the Authors Microservice running in the authors Pod, as we can see in the following picture. In the service.yaml we see a selector of the pod using the label 'app: authors'. kind : Service apiVersion : v1 metadata : name : authors labels : app : authors spec : selector : app : authors ports : - port : 3000 name : http type : NodePort --- Step 1: Ensure you are in the $ROOT_FOLDER/authors-java-jee/deployment \u00b6 cd $ROOT_FOLDER /authors-java-jee/deployment Step 2: Apply the service specification \u00b6 kubectl apply -f service.yaml Step 3: Verify the service in Kubernetes with kubectl \u00b6 kubectl get services Sample output: NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE authors NodePort 172 .21.107.135 <none> 3000 :31347/TCP 22s kubernetes ClusterIP 172 .21.0.1 <none> 443 /TCP 28h Step 4: Verify the service in the Kubernetes dashboard \u00b6 Open your Kubernetes Cluster in the IBM Cloud web console Open the Kubernetes dashbord In the overview scroll down until you see the created service Step 5: Verify the running Microservice on Kubernetes \u00b6 Get cluster (worker node) IP address and show the IP address workernodeip = $( ibmcloud ks workers --cluster cloud-native | awk '/Ready/ {print $2;exit;}' ) echo $workernodeip Example output: 184 .172.247.228 Expose a public port on your worker node and use the public IP address of the worker node to access your service in the cluster publicly from the internet. Get nodeport to access the service (do you remember the mapping?) nodeport = $( kubectl get svc authors --ignore-not-found --output 'jsonpath={.spec.ports[*].nodePort}' ) echo $nodeport Example output: 31347 Open API explorer. echo http:// ${ workernodeip } : ${ nodeport } /openapi/ui/ Sample output: http://184.172.247.228:31347/openapi/ui/ Copy and past the URL in a local browser on your PC: Execute curl to test the Authors service. curl http:// ${ clusterip } : ${ nodeport } /api/v1/getauthor?name = Niklas%20Heidloff Example output: { \"name\" : \"Niklas Heidloff\" , \"twitter\" : \"@nheidloff\" , \"blog\" : \"http://heidloff.net\" } Execute following curl command to test the HealthCheck implementation for the Authors service. curl http:// ${ workernodeip } : ${ nodeport } /health Example output: { \"checks\" :[{ \"data\" :{ \"authors\" : \"ok\" }, \"name\" : \"authors\" , \"state\" : \"UP\" }], \"outcome\" : \"UP\" } Optional: We can also verify that call in the browser. We can simply delete the deployed Authors Microservice with: kubectl delete -n default deployment authors Congratulations you have finished this hands-on workshop . Maybe you want to verify your learning in the Cloud Native Starter Level 1 Badge .","title":"Lab 3. Deploy to the Kubernetes"},{"location":"exercise-03/#deploy-to-kubernetes","text":"In this exercise we will work in the Kubernetes Web Console and with the Kubernetes CLI. \"Kubernetes (K8s) is an open-source system for automating deployment, scaling, and management of containerized applications.\" The following image is a simplified overview of the topics of that lab. This lab has two parts: Start build and save the container image Deploy the application and expose the service We will define and apply a deployment configuration (yaml) to create a Pod with our Microservice We will define a service which routes requests to the Pod with our Microservice The following gif is an animation of the simplified steps above in a sequence.","title":"Deploy to Kubernetes"},{"location":"exercise-03/#step-1-ensure-you-have-the-terminal-session-open-with-the-started-docker-image-and-you-have-downloaded-the-cloud-native-starter-project-also-in-this-running-container","text":"","title":"Step 1: Ensure you have the terminal session open with the started Docker image and you have downloaded the Cloud Native Starter project also in this running container"},{"location":"exercise-03/#step-2-navigate-to-the-folder-cloud-native-starterauthors-java-jee","text":"Note: You have cloned the project twice: first to your local machine and second into the Docker image. The code changes you did in execrise 2 on your local computer, don't exist in the running Docker container.","title":"Step 2:  Navigate to the folder cloud-native-starter/authors-java-jee"},{"location":"exercise-03/#1-build-and-save-the-container-image","text":"","title":"1. Build and save the container image"},{"location":"exercise-03/#step-1-build-and-save-the-container-image-in-the-ibm-cloud-container-registry","text":"Now we want to build and save a container image in the IBM Cloud Container Registry. Ensure you logon on to IBM Cloud. REMEMBER: You should know this from the prerequisites. You can follow the steps in the Access tab, by starting from After your cluster provision .. and inserting the commands into your terminal session. Logon to the IBM Cloud Container Registry (Ensure you are in the $ROOT_FOLDER/authors-java-jee ) cd $ROOT_FOLDER /authors-java-jee ibmcloud cr login List you namespaces inside the IBM Cloud Container Registry ibmcloud cr namespaces Example output: $ Listing namespaces for account 'Thomas Suedbroecker' s Account ' in registry ' us.icr.io ' ... $ $ Namespace $ cloud-native-suedbro Build the container image using buildah. buildah bud -t [ YOUR_REGISTRY ] / [ YOUR_REGISTRY_NAMESPACE ] /authors:v1 . 5. Now upload the container image to the IBM Cloud Container Registry. We use the information from step 3, where we got the list of namespaces. buildah push [ YOUR_REGISTRY ] / [ YOUR_REGISTRY_NAMESPACE ] /authors:v1 . Example command: * [YOUR_REGISTRY] = us.icr.io * [YOUR_REGISTRY_NAMESPACE] = cloud-native-suedbro buildah push us.icr.io/cloud-native-suedbro/authors:v1 . Optional: Verify the container upload in the IBM Cloud web UI. List the container images to verify the upload. ibmcloud cr images Example output: $ Listing images... $ $ Repository Tag Digest Namespace Created Size Security status $ us.icr.io/cloud-native-suedbro/authors 1 5a86758f1056 cloud-native-suedbro 2 minutes ago 226 MB 3 Issues $ $ OK Copy the REPOSITORY path for the uploaded Authors container image. In this sample case it would be: us.icr.io/cloud-native-suedbro/authors and save it somewhere, we need this later in the deployment.yaml configuration.","title":"Step 1: Build and save the container image in the IBM Cloud Container Registry"},{"location":"exercise-03/#2-apply-the-deployment","text":"This deployment will deploy a container to a Pod in Kubernetes. For more details we use the Kubernetes documentation for Pods. A Pod is the basic building block of Kubernetes-the smallest and simplest unit in the Kubernetes object model that you create or deploy. A Pod represents processes running on your Cluster . Here is a simplified image for that topic. The deployment.yaml file points to the container image that needs to be instantiated in the pod. Inside the container image cns-workshop-tools you can use the editor nano . nano deployment.yaml Let's start with the deployment yaml. For more details see the Kubernetes documentation for deployments. Definition of kind defines this as a Deployment configuration. kind: Deployment apiVersion: apps/v1 metadata: name: authors In the spec section we specify an app name and version label. spec: ... template: metadata: labels: app: authors version: v1 Then we define a name for the container and we provide the container image location, e.g. where the container can be found in the Container Registry . The containerPort depends on the port definition inside our Dockerfile and in our server.xml. We have previously talked about the usage of the HealthEndpoint class for our Authors service and here we see it the livenessProbe definition. spec: containers: - name: authors image: authors:1 ports: - containerPort: 3000 livenessProbe: This is the full deployment.yaml file. kind : Deployment apiVersion : apps/v1 metadata : name : authors spec : selector : matchLabels : app : authors version : v1 replicas : 1 template : metadata : labels : app : authors version : v1 spec : containers : - name : authors image : us.icr.io/cloud-native-suedbro/authors:1 ports : - containerPort : 3000 livenessProbe : exec : command : [ \"sh\" , \"-c\" , \"curl -s http://localhost:3000/\" ] initialDelaySeconds : 20 readinessProbe : exec : command : [ \"sh\" , \"-c\" , \"curl -s http://localhost:3000/health | grep -q authors\" ] initialDelaySeconds : 40 restartPolicy : Always","title":"2. Apply the Deployment"},{"location":"exercise-03/#step-1-apply-the-deployment","text":"Ensure you are in the $ROOT_FOLDER/authors-java-jee/deployment cd $ROOT_FOLDER /authors-java-jee/deployment Open the ../authors-java-jee/deployment/deployment.yaml file with a editor and replace the value for the container image location with the path we got from the IBM Container Registry and just replace the authors:1 text, and add following statement imagePullPolicy: Always and save the file. Note: With the specification imagePullPolicy: Always we force that the image is pulled from the IBM Cloud Container Registry and not cashed image in Kubernetes is possible used, when we change our container image IBM Cloud Container Registry. REMEMBER: You should have saved the IBM Container Registry information somewhere. Before: image: authors:1 Sample change: image: us.icr.io/cloud-native-suedbro/authors:1 imagePullPolicy: Always ports: - containerPort: 3000 Now we apply the deployment and we create a new Authors Pod. kubectl apply -f deployment.yaml","title":"Step 1: Apply the deployment"},{"location":"exercise-03/#step-2-verify-the-deployment-with-kubectl","text":"Insert this command and verify the output. kubectl get pods Sample output: NAME READY STATUS RESTARTS AGE authors-7b6dd98db-wl9wc 1 /1 Running 0 6m9s","title":"Step 2: Verify the deployment with kubectl"},{"location":"exercise-03/#step-3-verify-the-deployment-with-the-kubernetes-dashboard","text":"Open your Kubernetes Cluster in the IBM Cloud web console Open the Kubernetes dashbord In the overview you see the created deployment and the pod","title":"Step 3: Verify the deployment with the Kubernetes dashboard"},{"location":"exercise-03/#3-apply-the-service","text":"After the definition of the Pod we need to define how to access the Pod. For this we use a service in Kubernetes. For more details see the Kubernetes documentation for service. A Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them - sometimes called a micro-service. The set of Pods targeted by a Service is (usually) determined by a Label Selector. In the service we map the NodePort of the cluster to the port 3000 of the Authors Microservice running in the authors Pod, as we can see in the following picture. In the service.yaml we see a selector of the pod using the label 'app: authors'. kind : Service apiVersion : v1 metadata : name : authors labels : app : authors spec : selector : app : authors ports : - port : 3000 name : http type : NodePort ---","title":"3. Apply the service"},{"location":"exercise-03/#step-1-ensure-you-are-in-the-root_folderauthors-java-jeedeployment","text":"cd $ROOT_FOLDER /authors-java-jee/deployment","title":"Step 1: Ensure you are in the $ROOT_FOLDER/authors-java-jee/deployment"},{"location":"exercise-03/#step-2-apply-the-service-specification","text":"kubectl apply -f service.yaml","title":"Step 2: Apply the service specification"},{"location":"exercise-03/#step-3-verify-the-service-in-kubernetes-with-kubectl","text":"kubectl get services Sample output: NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE authors NodePort 172 .21.107.135 <none> 3000 :31347/TCP 22s kubernetes ClusterIP 172 .21.0.1 <none> 443 /TCP 28h","title":"Step 3: Verify the service in Kubernetes with kubectl"},{"location":"exercise-03/#step-4-verify-the-service-in-the-kubernetes-dashboard","text":"Open your Kubernetes Cluster in the IBM Cloud web console Open the Kubernetes dashbord In the overview scroll down until you see the created service","title":"Step 4: Verify the service in the Kubernetes dashboard"},{"location":"exercise-03/#step-5-verify-the-running-microservice-on-kubernetes","text":"Get cluster (worker node) IP address and show the IP address workernodeip = $( ibmcloud ks workers --cluster cloud-native | awk '/Ready/ {print $2;exit;}' ) echo $workernodeip Example output: 184 .172.247.228 Expose a public port on your worker node and use the public IP address of the worker node to access your service in the cluster publicly from the internet. Get nodeport to access the service (do you remember the mapping?) nodeport = $( kubectl get svc authors --ignore-not-found --output 'jsonpath={.spec.ports[*].nodePort}' ) echo $nodeport Example output: 31347 Open API explorer. echo http:// ${ workernodeip } : ${ nodeport } /openapi/ui/ Sample output: http://184.172.247.228:31347/openapi/ui/ Copy and past the URL in a local browser on your PC: Execute curl to test the Authors service. curl http:// ${ clusterip } : ${ nodeport } /api/v1/getauthor?name = Niklas%20Heidloff Example output: { \"name\" : \"Niklas Heidloff\" , \"twitter\" : \"@nheidloff\" , \"blog\" : \"http://heidloff.net\" } Execute following curl command to test the HealthCheck implementation for the Authors service. curl http:// ${ workernodeip } : ${ nodeport } /health Example output: { \"checks\" :[{ \"data\" :{ \"authors\" : \"ok\" }, \"name\" : \"authors\" , \"state\" : \"UP\" }], \"outcome\" : \"UP\" } Optional: We can also verify that call in the browser. We can simply delete the deployed Authors Microservice with: kubectl delete -n default deployment authors Congratulations you have finished this hands-on workshop . Maybe you want to verify your learning in the Cloud Native Starter Level 1 Badge .","title":"Step 5: Verify the running Microservice on Kubernetes"},{"location":"optional-lab-01/","text":"Deploy to Code Engine \u00b6 In this optional lab we will deploy our application to the IBM Cloud Code Engine . This optional lab is not needed to complete the Cloud Native Starter Badge 1 . If you want to learn more about deploying a Microservice Application to Code Engine, check out this Workshop. Prerequisites \u00b6 You need to upload the container image to the IBM Cloud Container Registry , if you haven't done that already (please follow the steps in exercise 3 \"Deploy to Kubernetes\"). Create a Code Engine Project \u00b6 Note: you need a PayAsYouGo Account, in order to use Code Engine . In order to create a Code Engine project, you can either search for Code Engine in your IBM Cloud Dashboard and navigate to Projects , or you can follow this link instead. Now you press Create , enter a Name, select a suitable location, select Default as your resource group and click Create again. Once you've done that, you should be able to see your newly created project here . Prepare Container Registry \u00b6 Step 1: Create an Access Key for your Registry \u00b6 In order for Code Engine to access your container image, we need to create an API-Key. Open the following link and click on Create an IBM Cloud API key . https://cloud.ibm.com/iam/apikeys Enter a name and click Create . Now copy and save the API-key, as it won't be shown again. Step 2: Create a Registry Access \u00b6 Follow this link , and click on the project you created earlier. On the left side you it should look like this: Click on Registry access and click on Create . Give it a name, and input the following parameters: Registry source: Custom Registry server: the server your container registry is located in for example us.icr.io Password: The API-key you created earlier E-mail: Your E-mail Afterwards click Create again. Deploy to Code Engine \u00b6 Step 1: Get the location of your container image \u00b6 In order to create our Code Engine deployment, we need to know the location of our container image. From the IBM Cloud Dashboard, navigate to Container registry and click on Images . Alternatively, you can follow this link . Now look for your image, click on it and copy its link. Step 2: Deploy the application \u00b6 Navigate to the Code Engine project you created earlier, click on Applications and press Create . Now you should see something similar to this: Fill in the following parameters: Name: a suitable name, for example authors Select Container image Image reference: The link to your container image you copied earlier Registry access: select the Registry access you created earlier Listening Port: 3000 Endpoints: public Now scroll down to Runtime settings and click on it. Set both the Min Number of Instances as well as the Max Number of Instances to 1 , and select 0.125vCPU/0.25 GB as your Instance resources . Now you press create, and wait a bit for Code Engine to deploy your application. Step 3: Verify that the deployment worked \u00b6 Go to your Code Engine Project, and click on Applications . If the deployment worked, it should look similar to the following picture. Click on Open URL , and wait for the new browsertab to open. Now add /openapi/ui/ to the end of the URL to check that your application is working properly. Congratulations you have finished this optional lab .","title":"Lab 1. Deploy to Code Engine"},{"location":"optional-lab-01/#deploy-to-code-engine","text":"In this optional lab we will deploy our application to the IBM Cloud Code Engine . This optional lab is not needed to complete the Cloud Native Starter Badge 1 . If you want to learn more about deploying a Microservice Application to Code Engine, check out this Workshop.","title":"Deploy to Code Engine"},{"location":"optional-lab-01/#prerequisites","text":"You need to upload the container image to the IBM Cloud Container Registry , if you haven't done that already (please follow the steps in exercise 3 \"Deploy to Kubernetes\").","title":"Prerequisites"},{"location":"optional-lab-01/#create-a-code-engine-project","text":"Note: you need a PayAsYouGo Account, in order to use Code Engine . In order to create a Code Engine project, you can either search for Code Engine in your IBM Cloud Dashboard and navigate to Projects , or you can follow this link instead. Now you press Create , enter a Name, select a suitable location, select Default as your resource group and click Create again. Once you've done that, you should be able to see your newly created project here .","title":"Create a Code Engine Project"},{"location":"optional-lab-01/#prepare-container-registry","text":"","title":"Prepare Container Registry"},{"location":"optional-lab-01/#step-1-create-an-access-key-for-your-registry","text":"In order for Code Engine to access your container image, we need to create an API-Key. Open the following link and click on Create an IBM Cloud API key . https://cloud.ibm.com/iam/apikeys Enter a name and click Create . Now copy and save the API-key, as it won't be shown again.","title":"Step 1: Create an Access Key for your Registry"},{"location":"optional-lab-01/#step-2-create-a-registry-access","text":"Follow this link , and click on the project you created earlier. On the left side you it should look like this: Click on Registry access and click on Create . Give it a name, and input the following parameters: Registry source: Custom Registry server: the server your container registry is located in for example us.icr.io Password: The API-key you created earlier E-mail: Your E-mail Afterwards click Create again.","title":"Step 2: Create a Registry Access"},{"location":"optional-lab-01/#deploy-to-code-engine_1","text":"","title":"Deploy to Code Engine"},{"location":"optional-lab-01/#step-1-get-the-location-of-your-container-image","text":"In order to create our Code Engine deployment, we need to know the location of our container image. From the IBM Cloud Dashboard, navigate to Container registry and click on Images . Alternatively, you can follow this link . Now look for your image, click on it and copy its link.","title":"Step 1: Get the location of your container image"},{"location":"optional-lab-01/#step-2-deploy-the-application","text":"Navigate to the Code Engine project you created earlier, click on Applications and press Create . Now you should see something similar to this: Fill in the following parameters: Name: a suitable name, for example authors Select Container image Image reference: The link to your container image you copied earlier Registry access: select the Registry access you created earlier Listening Port: 3000 Endpoints: public Now scroll down to Runtime settings and click on it. Set both the Min Number of Instances as well as the Max Number of Instances to 1 , and select 0.125vCPU/0.25 GB as your Instance resources . Now you press create, and wait a bit for Code Engine to deploy your application.","title":"Step 2: Deploy the application"},{"location":"optional-lab-01/#step-3-verify-that-the-deployment-worked","text":"Go to your Code Engine Project, and click on Applications . If the deployment worked, it should look similar to the following picture. Click on Open URL , and wait for the new browsertab to open. Now add /openapi/ui/ to the end of the URL to check that your application is working properly. Congratulations you have finished this optional lab .","title":"Step 3: Verify that the deployment worked"},{"location":"pre-work/","text":"Overview \u00b6 In order to run this workshop you need an IBM Cloud account and free IBM Cloud Kubernetes Cluster. To create a free IBM Cloud Kubernetes Cluster you need a Pay-As-You-Go Account for IBM Cloud. ( Account Types ) We will use the following IBM Cloud Services in this hands-on workshop: IBM Cloud Kubernetes Service IBM Cloud Container Registry Service Tools \u00b6 We created a Docker image that we use in this workshop. The Docker image contains all needed CLIs such as: git curl IBM Cloud CLI IBM Cloud CLI releases Docker kubectl So, in order to complete the workshop, you need to install Docker Desktop on your local machine. Docker Desktop is available for Mac and Windows and the Docker Engine can be run natively on Linux . We will use two terminal sessions \u00b6 The first terminal session is for the developer focused exercises 1 and 2. The second terminal session is for exercise 3 deploy the Microservice to Kubernetes, here you will work in a preconfigured Container image.","title":"Overview"},{"location":"pre-work/#overview","text":"In order to run this workshop you need an IBM Cloud account and free IBM Cloud Kubernetes Cluster. To create a free IBM Cloud Kubernetes Cluster you need a Pay-As-You-Go Account for IBM Cloud. ( Account Types ) We will use the following IBM Cloud Services in this hands-on workshop: IBM Cloud Kubernetes Service IBM Cloud Container Registry Service","title":"Overview"},{"location":"pre-work/#tools","text":"We created a Docker image that we use in this workshop. The Docker image contains all needed CLIs such as: git curl IBM Cloud CLI IBM Cloud CLI releases Docker kubectl So, in order to complete the workshop, you need to install Docker Desktop on your local machine. Docker Desktop is available for Mac and Windows and the Docker Engine can be run natively on Linux .","title":"Tools"},{"location":"pre-work/#we-will-use-two-terminal-sessions","text":"The first terminal session is for the developer focused exercises 1 and 2. The second terminal session is for exercise 3 deploy the Microservice to Kubernetes, here you will work in a preconfigured Container image.","title":"We will use two terminal sessions"},{"location":"pre-work/1-REGISTER/","text":"Register for IBM Cloud \u00b6 Step 1: Open a browser window and navigate to the IBM Cloud Registration page \u00b6 Step 2: Fill in the registration form and follow the link in the confirmation email to confirm your account once it arrives \u00b6 Step 3: Login into IBM Cloud using your account credentials \u00b6 By default, all new IBM Cloud accounts are set to pay as you go . Please visit the IBM Cloud pricing for details.","title":"Register for IBM Cloud"},{"location":"pre-work/1-REGISTER/#register-for-ibm-cloud","text":"","title":"Register for IBM Cloud"},{"location":"pre-work/1-REGISTER/#step-1-open-a-browser-window-and-navigate-to-the-ibm-cloud-registration-page","text":"","title":"Step 1: Open a browser window and navigate to the IBM Cloud Registration page"},{"location":"pre-work/1-REGISTER/#step-2-fill-in-the-registration-form-and-follow-the-link-in-the-confirmation-email-to-confirm-your-account-once-it-arrives","text":"","title":"Step 2: Fill in the registration form and follow the link in the confirmation email to confirm your account once it arrives"},{"location":"pre-work/1-REGISTER/#step-3-login-into-ibm-cloud-using-your-account-credentials","text":"By default, all new IBM Cloud accounts are set to pay as you go . Please visit the IBM Cloud pricing for details.","title":"Step 3: Login into IBM Cloud using your account credentials"},{"location":"pre-work/3-CREATE_KUBERNETES_CLUSTER/","text":"Create a free IBM Cloud Kubernetes cluster \u00b6 Step 1: Logon to IBM Cloud \u00b6 Step 2: Select in the menu \"Catalog\" and search for \"Kubernetes Service\" \u00b6 Step 3: Click on \"Kubernetes Service\" \u00b6 Step 4: Select Free cluster \u00b6 Step 5: Click on the Kubernetes Services and select \"Free\" \u00b6 Ensure you set following values in the creation dialog: Cluster name: cloud-native Resource group: Default Step 6: Press \"Create custer\" \u00b6 Step 7: Now you will be forwarded to your cluster on IBM Cloud and you can verify the status of the creation of your cluster \u00b6 The creation of the cluster takes up to 20 min .","title":"Create a free Kubernetes cluster"},{"location":"pre-work/3-CREATE_KUBERNETES_CLUSTER/#create-a-free-ibm-cloud-kubernetes-cluster","text":"","title":"Create a free IBM Cloud Kubernetes cluster"},{"location":"pre-work/3-CREATE_KUBERNETES_CLUSTER/#step-1-logon-to-ibm-cloud","text":"","title":"Step 1: Logon to IBM Cloud"},{"location":"pre-work/3-CREATE_KUBERNETES_CLUSTER/#step-2-select-in-the-menu-catalog-and-search-for-kubernetes-service","text":"","title":"Step 2: Select in the menu \"Catalog\" and search for \"Kubernetes Service\""},{"location":"pre-work/3-CREATE_KUBERNETES_CLUSTER/#step-3-click-on-kubernetes-service","text":"","title":"Step 3: Click on \"Kubernetes Service\""},{"location":"pre-work/3-CREATE_KUBERNETES_CLUSTER/#step-4-select-free-cluster","text":"","title":"Step 4: Select Free cluster"},{"location":"pre-work/3-CREATE_KUBERNETES_CLUSTER/#step-5-click-on-the-kubernetes-services-and-select-free","text":"Ensure you set following values in the creation dialog: Cluster name: cloud-native Resource group: Default","title":"Step 5: Click on the Kubernetes Services and select \"Free\""},{"location":"pre-work/3-CREATE_KUBERNETES_CLUSTER/#step-6-press-create-custer","text":"","title":"Step 6: Press \"Create custer\""},{"location":"pre-work/3-CREATE_KUBERNETES_CLUSTER/#step-7-now-you-will-be-forwarded-to-your-cluster-on-ibm-cloud-and-you-can-verify-the-status-of-the-creation-of-your-cluster","text":"The creation of the cluster takes up to 20 min .","title":"Step 7: Now you will be forwarded to your cluster on IBM Cloud and you can verify the status of the creation of your cluster"},{"location":"pre-work/4-CONTAINER_REGISTRY/","text":"Configure the IBM Cloud Container Registry \u00b6 Step 1: Select in Kubernetes the entry Registry and ensure your are in the Dallas location \u00b6 Step 2: The create a namespace with a unique name cloud-native-[YOURNAME] \u00b6 Note: Namespaces are required to be unique across the entire region that the specific registry is located in, not just unique to your account . This is mentioned in the following public documentation . Now we have created a free IBM Kubernetes Cluster and we configured the IBM Cloud Container Registry.","title":"Configure the container registry"},{"location":"pre-work/4-CONTAINER_REGISTRY/#configure-the-ibm-cloud-container-registry","text":"","title":"Configure the IBM Cloud Container Registry"},{"location":"pre-work/4-CONTAINER_REGISTRY/#step-1-select-in-kubernetes-the-entry-registry-and-ensure-your-are-in-the-dallas-location","text":"","title":"Step 1: Select in Kubernetes the entry Registry and ensure your are in the Dallas location"},{"location":"pre-work/4-CONTAINER_REGISTRY/#step-2-the-create-a-namespace-with-a-unique-name-cloud-native-yourname","text":"Note: Namespaces are required to be unique across the entire region that the specific registry is located in, not just unique to your account . This is mentioned in the following public documentation . Now we have created a free IBM Kubernetes Cluster and we configured the IBM Cloud Container Registry.","title":"Step 2: The create a namespace with a unique name cloud-native-[YOURNAME]"},{"location":"pre-work/5-SETUP-ALL/","text":"Using local Code and the prebuilt Docker image with the Code in the Container \u00b6 Remember! We use two terminal sessions \u00b6 The first terminal session is for the developer focused exercises 1 and 2. The second terminal session is for exercise 3 deploy the Microservice to Kubernetes, here you will work in a preconfigured Container image. Step 1: Code locally - Open a terminal session and run these commands \u00b6 Download the project locally to work in the Developer labs locally. git clone https://github.com/IBM/cloud-native-starter cd cloud-native-starter ROOT_FOLDER = $( pwd ) The local project is needed for Java development labs 2 and 3, because you can't use Docker in the 'cns-workshop-tools' Docker image. (for more see this article ) Step 2: Open new terminal session and run these commands \u00b6 Start the container docker run -it --privileged --rm quay.io/tsuedbroecker/cns-workshop-tools:buildah-v1 Step 3: After the container has been started, run these commands inside your running Docker image to get the lastest version of the workshop \u00b6 cd / git clone https://github.com/IBM/cloud-native-starter.git cd cloud-native-starter ROOT_FOLDER = $( pwd ) Step 4: Verfiy the tool prerequisites on for the workshop \u00b6 chmod u+x iks-scripts/*.sh chmod u+x scripts/*.sh ./iks-scripts/check-prerequisites.sh","title":"Setup for local development and cloud deployment"},{"location":"pre-work/5-SETUP-ALL/#using-local-code-and-the-prebuilt-docker-image-with-the-code-in-the-container","text":"","title":"Using local Code and the prebuilt Docker image with the Code in the Container"},{"location":"pre-work/5-SETUP-ALL/#remember-we-use-two-terminal-sessions","text":"The first terminal session is for the developer focused exercises 1 and 2. The second terminal session is for exercise 3 deploy the Microservice to Kubernetes, here you will work in a preconfigured Container image.","title":"Remember! We use two terminal sessions"},{"location":"pre-work/5-SETUP-ALL/#step-1-code-locally-open-a-terminal-session-and-run-these-commands","text":"Download the project locally to work in the Developer labs locally. git clone https://github.com/IBM/cloud-native-starter cd cloud-native-starter ROOT_FOLDER = $( pwd ) The local project is needed for Java development labs 2 and 3, because you can't use Docker in the 'cns-workshop-tools' Docker image. (for more see this article )","title":"Step 1: Code locally - Open a terminal session and run these commands"},{"location":"pre-work/5-SETUP-ALL/#step-2-open-new-terminal-session-and-run-these-commands","text":"Start the container docker run -it --privileged --rm quay.io/tsuedbroecker/cns-workshop-tools:buildah-v1","title":"Step 2: Open new terminal session and run these commands"},{"location":"pre-work/5-SETUP-ALL/#step-3-after-the-container-has-been-started-run-these-commands-inside-your-running-docker-image-to-get-the-lastest-version-of-the-workshop","text":"cd / git clone https://github.com/IBM/cloud-native-starter.git cd cloud-native-starter ROOT_FOLDER = $( pwd )","title":"Step 3: After the container has been started, run these commands inside your running Docker image to get the lastest version of the workshop"},{"location":"pre-work/5-SETUP-ALL/#step-4-verfiy-the-tool-prerequisites-on-for-the-workshop","text":"chmod u+x iks-scripts/*.sh chmod u+x scripts/*.sh ./iks-scripts/check-prerequisites.sh","title":"Step 4: Verfiy the tool prerequisites on for the workshop"},{"location":"pre-work/6-ACCESS_TO_CLUSTER/","text":"Verify Access to Kubernetes on the IBM Cloud \u00b6 This is a preparation for exercise 3, when we will connect to the free Kubernetes cluster in IBM Cloud. Step 1: Logon to the IBM Cloud web console \u00b6 Step 2: Select Kubernetes in the menu \u00b6 Step 3: Chose Clusters and click on your Kubernetes cluster \u00b6 Step 4: Ensure you cluster is deployed \u00b6 Note: Ensure you are in the terminal session with the running Docker container. Step 5: Open Actions -> Connect via CLI \u00b6 Then follow the steps and insert the commands into your second terminal session. Connect via CLI","title":"Access the Kubernetes cluster"},{"location":"pre-work/6-ACCESS_TO_CLUSTER/#verify-access-to-kubernetes-on-the-ibm-cloud","text":"This is a preparation for exercise 3, when we will connect to the free Kubernetes cluster in IBM Cloud.","title":"Verify Access to Kubernetes on the IBM Cloud"},{"location":"pre-work/6-ACCESS_TO_CLUSTER/#step-1-logon-to-the-ibm-cloud-web-console","text":"","title":"Step 1: Logon to the IBM Cloud web console"},{"location":"pre-work/6-ACCESS_TO_CLUSTER/#step-2-select-kubernetes-in-the-menu","text":"","title":"Step 2: Select Kubernetes in the menu"},{"location":"pre-work/6-ACCESS_TO_CLUSTER/#step-3-chose-clusters-and-click-on-your-kubernetes-cluster","text":"","title":"Step 3: Chose Clusters and click on your Kubernetes cluster"},{"location":"pre-work/6-ACCESS_TO_CLUSTER/#step-4-ensure-you-cluster-is-deployed","text":"Note: Ensure you are in the terminal session with the running Docker container.","title":"Step 4: Ensure you cluster is deployed"},{"location":"pre-work/6-ACCESS_TO_CLUSTER/#step-5-open-actions-connect-via-cli","text":"Then follow the steps and insert the commands into your second terminal session. Connect via CLI","title":"Step 5: Open Actions -&gt; Connect via CLI"}]}